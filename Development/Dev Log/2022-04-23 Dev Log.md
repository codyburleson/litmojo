## Objectives
- Complete the [Creating an editor](https://unifiedjs.com/learn/guide/create-an-editor/) tutorial in the Unified Learning Guide.

## Conversion, Assembly and the Unfied Collective

### Conversion and Assembly
Two of the goals for the LitMojo plugin are that it will make it easy for writers to convert from one document format to another and to assemble multiple documents together in a specified order, then output the assembled result in a variety of formats. Borrowing from the popular app for writers called Scrivener, the assembly feature is often also referred to as "compiling." 

### Obsidian Longform
There is a plugin for Obsidian that does this already called [Longform](https://github.com/kevboh/longform). While Longform does the job, it does not yet do so in a way that's sufficient for my personal needs. That doesn't mean that it will not be suffiecient for your own needs, so try it for yourself; it's pretty powerful and clearly, a lot of work went into it.

### Pandoc and Obsidian Pandoc
Users on the [Obsidian Discord chat](https://discord.gg/veuWUTm) have also noted that, in combination with the [Obsidian Pandoc Plugin](https://github.com/OliverBalfour/obsidian-pandoc), [Pandoc](https://pandoc.org/installing.html) can also do the jobs of conversion and assembly. While Pandoc is very powerful and sophisticated, it is an external, 3rd-party program that is command-line centric and not something I think the average writer is going to want to mess with; especially when you then have to bridge to it with a plugin. What's more, it focuses only on the conversion and assembly use-cases. A tool for serious writers must eventually do much more than that and it must, in the best way possible, honor the persona that it serves - empowering users to write and publish, not waste time wrestling with technicalities. While I personally have no trouble with Pandoc, I know for sure that just the command-line installation and terminal procedures alone would eliminate most of the users I hope to serve.

### Unified
I've already been studying on an architecture that would make the LitMojo engine able to do flexible conversion and assembly. The answer is clearly the [Unified Collective](https://unifiedjs.com/). Unfied is a suite of tools that help you compile content to syntax trees and syntax trees to content. You can, for example, parse a markdown document into an AST (an Abstract Syntax Tree). Plugins within the ecosystem can then be used to do a number of interesting things with elements in the tree and pipelines can be made of both plugins and tree converters. You can go easily from markdown to HTML and vise-versa, for example.

I've been doing some tutorials around unified to get more proficient with it before I start putting it in the plugin code and that's what I'm going to continue doing today. Today, I'm doing the tutorial called [Creating an editor](https://unifiedjs.com/learn/guide/create-an-editor/) from the [Unified Learning Guide](https://unifiedjs.com/learn/).

I'm sure my notes here will just be a sloppy regurgitation of the tutorial itself, but it helps me study and learn to write things as I work.

## The Editor
This is what we're building:

An editor that highlights sentences in text based on how many words they have. The user is able to change text, and it highlights live.

I'm very curious about this because it does a very fast job of color-coding as you edit using, not [React](https://reactjs.org/), but a library called [virtual-dom](https://github.com/Matt-Esch/virtual-dom), which I've never yet used. Maybe I'll discover something for the toolbox!

![[write-music-screenshot.png]]

You can also [view this project](https://wooorm.com/write-music/) with some more features online.

## Steps

```bash
cd repos
mkdir demo
cd demo
touch index.js
touch index.html
touch index.css
npm init
```

This will eventually give us the following:

```bash
demo/
├─ index.js
├─ build.js
├─ index.html
├─ index.css
└─ package.json
```

where `demo/` is our directory, and `build.js` is the JavaScript generated by compiling `index.js`.

Fill package.json with the following:

```bash
{
    "name": "demo",
    "private": true,
    "type": "module",
    "devDependencies": {
        "esbuild": "^0.13.0",
        "prettier": "^2.0.0",
        "xo": "^0.44.0"
    },
    "scripts": {
        "build": "esbuild index.js --bundle --minify --target=es2020 --format=esm --outfile=build.js",
        "lint": "prettier . -w && xo",
        "test": "npm run build && npm run lint"
    },
    "prettier": {
        "tabWidth": 2,
        "useTabs": false,
        "singleQuote": true,
        "bracketSpacing": false,
        "semi": false,
        "trailingComma": "none"
    },
    "xo": {
        "envs": [
            "browser"
        ],
        "prettier": true,
        "ignore": [
            "build.js"
        ]
    }
}
```

[`private: true`](https://docs.npmjs.com/files/package.json#private) means you can’t accidentally publish your package to npm.

Run `npm install` and `npm test` and we should see `build.js` appear too. 

Now, fill `index.html` with the following:

```html
<!DOCTYPE html>
<meta charset="utf8" />
<title>demo</title>
<link rel="stylesheet" href="index.css" />
<div id="root"></div>
<script type="module" src="build.js"></script>
```

This links `index.css` and `build.js`, and adds an element (`#root`) which we’ll add our editor to later. Oh, did you know that `<html>`, `<head>`, and `<body>` are optional? For this example we’ll keep the HTML minimal, but feel free to add them if you prefer them.

==Interesting. No. I did not know they were optional! You learn something new every day!==

Also add `.prettierignore` file to not format our build.

==I didn't know that either. I need to do tutorials more often.==

**.prettierignore**

```
build.js
```

Add the following to index.js...

**index.js**

```js
import h from 'virtual-dom/h.js'
import createElement from 'virtual-dom/create-element.js'
import diff from 'virtual-dom/diff.js'
import patch from 'virtual-dom/patch.js'

const root = document.querySelector('#root')
let tree = render('The initial text.')
let dom = root.append(createElement(tree))

function onchange(ev) {
  const next = render(ev.target.value)
  dom = patch(dom, diff(tree, next))
  tree = next
}

function render(text) {
  const node = parse(text)

  return h('div', {className: 'editor'}, [
    h('div', {key: 'draw', className: 'draw'}, highlight(node)),
    h('textarea', {
      key: 'area',
      value: text,
      oninput: onchange
    })
  ])

  function parse() {}

  function highlight() {}
}
```

Don’t forget to `npm install virtual-dom`.

virtual-dom advertises itself on npm as:

> "A JavaScript DOM model supporting element creation, diff computation and patch operations for efficient re-rendering"

You can find the documentation for the seperate components in their READMEs

-   For `create-element.js` see the [vdom README](https://github.com/Matt-Esch/virtual-dom/blob/HEAD/vdom/README.md)
-   For `diff.js` see the [vtree README](https://github.com/Matt-Esch/virtual-dom/blob/HEAD/vtree/README.md)
-   For `h.js` see the [virtual-hyperscript README](https://github.com/Matt-Esch/virtual-dom/blob/HEAD/virtual-hyperscript/README.md)
-   For `patch.js` see the [vdom README](https://github.com/Matt-Esch/virtual-dom/blob/HEAD/vdom/README.md)

For information about the type signatures of these modules feel free to read the [javascript signature definition](https://github.com/Matt-Esch/virtual-dom/blob/HEAD/docs.jsig)

**Summary of what all the things in index.js mean:**

To summarize what all these things in the code mean:

-   `h` creates “virtual” nodes
-   `createElement` turns them into DOM nodes
-   `diff` finds the difference between two virtual nodes
-   `patch` applies `diff` to a DOM node
-   `root` is our anchor into the document
-   `tree` is the current virtual tree
-   `dom` is the current DOM tree
-   `onchange` handles any state change (the text in our case)
-   `render` creates a new virtual tree based on that state
-   `parse` transforms the state into a natural language syntax tree
-   `highlight` transforms that syntax tree into a virtual tree

In `render`, we’re creating two elements: a `<div>` that we’ll draw our syntax highlighting in, and a `<textarea>` that the user can edit. Both are wrapped in a parent `<div>`. We’ll style the text area and the drawing area exactly the same, and position the text above the drawing area, with the following styles.

**index.css...**

```css
html {
  font-size: 16px;
  line-height: 1.5;
}

.editor {
  position: relative;
  max-width: 37em;
  margin: auto;
  overflow: hidden;
}

textarea,
.draw {
  margin: 0;
  padding: 0;
  width: 100%;
  border: none;
  outline: none;
  resize: none;
  overflow: hidden;
  /* Can’t use a nice font: kerning renders differently in textareas. */
  font-family: monospace;
  line-height: inherit;
  font-size: inherit;
  background: transparent;
  white-space: pre-wrap;
  word-wrap: break-word;
  font-size: inherit;
  line-height: inherit;
}

textarea {
  color: inherit;
  position: absolute;
  top: 0;
}

.draw {
  min-height: 100vh;
}
```

That’s quite a bit of code: ==mainly to enforce the same styles on our text and drawing areas.==

### Natural language syntax tree

Now, let’s set up our natural language syntax tree parsing. We’ll use [unified](https://unifiedjs.com/explore/package/unified/) (d’oh), and [`retext-english`](https://unifiedjs.com/explore/package/retext-english/) to parse English natural language.

Change `index.js` like so:

Add:

```js
import {unified} from 'unified'
import retextEnglish from 'retext-english'

const processor = unified().use(retextEnglish)
```

Now update `function parse() {}`

```js
function parse(value) {
    return processor.runSync(processor.parse(value))
}
```

> Don’t forget to `npm install unified retext-english`.

Sweet, now we have access to a lot of info on the text. It still doesn’t do anything yet though. Let’s add some usefulness.

### Virtual DOM
Our next task is to go from a natural language syntax tree to a virtual DOM. We already have `highlight` for that, but it’s empty, so let’s add code to fill it:

We're going to update the `highlight()` function and add the `one()` function...

```js
function highlight(node) {
	const results = []
	let index = -1

	while (++index < node.children.length) {
		results.push(...one(node.children[index]))
	}

	return results
}

function one(node) {
	const result = 'value' in node ? [node.value] : highlight(node)
	return result
}
```

`highlight` searches all children in the given `node`, and `one` returns either the “text content” of a node, or the result of searching its children for text content.

If you’d now run `npm test` again, and open `index.html` in your browser, you’ll see that the drawing area already has our text (it’s hidden with styles, but you should be able to see it in your web inspector).

Note: To serve the index.html file, I'm using the VS Code [Live Server extension](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer), which complains that we DO need an HTML head and body; so - I'm thoring those in.

We need one more thing before we can start highlighting: we need to detect sentences, and apply styles to them. Change `index.js` like so:

```js
import h from 'virtual-dom/h.js'
import createElement from 'virtual-dom/create-element.js'
import diff from 'virtual-dom/diff.js'
import patch from 'virtual-dom/patch.js'
import {unified} from 'unified'
import retextEnglish from 'retext-english'

const processor = unified().use(retextEnglish)
const root = document.querySelector('#root')
let tree = render('The initial text.')
let dom = root.append(createElement(tree))

function onchange(ev) {
  const next = render(ev.target.value)
  dom = patch(dom, diff(tree, next))
  tree = next
}

function render(text) {
  const node = parse(text)
  let key = 0

  return h('div', {className: 'editor'}, [
    h('div', {key: 'draw', className: 'draw'}, highlight(node)),
    h('textarea', {
      key: 'area',
      value: text,
      oninput: onchange
    })
  ])

  function parse(value) {
    return processor.runSync(processor.parse(value))
  }

  function highlight(node) {
    const results = []
    let index = -1

    while (++index < node.children.length) {
      results.push(...one(node.children[index]))
    }

    return results
  }

  function one(node) {
    const result = 'value' in node ? [node.value] : highlight(node)

    if (node.type === 'SentenceNode') {
      key++
      return [
        h(
          'span',
          {key: 's-' + key, style: {backgroundColor: color(count(node))}},
          result
        )
      ]
    }

    return result
  }
  
  function count() {}

  function color() {}
}
```

`key` is needed for `virtual-dom` [to be performant](https://github.com/Matt-Esch/virtual-dom/tree/HEAD/virtual-hyperscript#key).

We don’t color sentences yet, but there’s `<span>` elements wrapping them now. You can see that in action by running `npm test` again and using your web inspector to inspect the drawing area.

We’ve also set up two functions to highlight sentences. `count` will count the number of words of a given sentence, and `color` will pick a corresponding color.

### Highlight

Now, let’s add colors. Update `index.js` like so:

```js
import h from 'virtual-dom/h.js'
import createElement from 'virtual-dom/create-element.js'
import diff from 'virtual-dom/diff.js'
import patch from 'virtual-dom/patch.js'
import {unified} from 'unified'
import retextEnglish from 'retext-english'
import {visit} from 'unist-util-visit'

const hues = [0]

const processor = unified().use(retextEnglish)
const root = document.querySelector('#root')
let tree = render('The initial text.')
let dom = root.append(createElement(tree))

function onchange(ev) {
  const next = render(ev.target.value)
  dom = patch(dom, diff(tree, next))
  tree = next
}

function render(text) {
  const node = parse(text)
  let key = 0

  return h('div', {className: 'editor'}, [
    h('div', {key: 'draw', className: 'draw'}, highlight(node)),
    h('textarea', {
      key: 'area',
      value: text,
      oninput: onchange
    })
  ])

  function parse(value) {
    return processor.runSync(processor.parse(value))
  }

  function highlight(node) {
    const results = []
    let index = -1

    while (++index < node.children.length) {
      results.push(...one(node.children[index]))
    }

    return results
  }

  function one(node) {
    const result = 'value' in node ? [node.value] : highlight(node)

    if (node.type === 'SentenceNode') {
      key++
      return [
        h(
          'span',
          {key: 's-' + key, style: {backgroundColor: color(count(node))}},
          result
        )
      ]
    }

    return result
  }

  function count(node) {
    let value = 0

    visit(node, 'WordNode', () => {
      value++
    })

    return value
  }

  function color(count) {
    const value = count < hues.length ? hues[count] : hues[hues.length - 1]
    return 'hsl(' + [value, '93%', '85%'].join(', ') + ')'
  }
}

```

==At this point,I do have some errors in my console...==

```bash
87build.js:8 Uncaught TypeError: Cannot read properties of undefined (reading 'ownerDocument')
    at Object.no [as patch] (build.js:8:8344)
    at vt (build.js:8:8253)
    at HTMLTextAreaElement.Lo (build.js:9:6277)
```

### Color

One color isn’t that cool, and we’re trying to recreate that [visual by @gregoryciotti](https://twitter.com/gregoryciotti/status/639837682844090369). We need some more colors. From that image, I deducted the following hues. But you could use any hues you like!

To match that image, change `hues` like so:

Change this...

```js
const hues = [0]
```

To this...

```js
const hues = [60, 60, 60, 300, 300, 0, 0, 120, 120, 120, 120, 120, 120, 180]
```

### Squashing bugs

💃 After running `npm test` again, and reopening `index.html` in your browser, you should now see `The initial text` in purple! If you add more sentences, they each should receive colors based on how many words they have.

If you add more text, you’ll notice that our drawing area grows nicely, but our text area does not. That’s because this example positions the `<textarea>` absolutely on top of the drawing area. The easiest way to get both areas the same height, is with the following slightly hacky code:

**index.js...**

```js
import h from 'virtual-dom/h.js'
import createElement from 'virtual-dom/create-element.js'
import diff from 'virtual-dom/diff.js'
import patch from 'virtual-dom/patch.js'
import { unified } from 'unified'
import retextEnglish from 'retext-english'
import { visit } from 'unist-util-visit'

const hues = [60, 60, 60, 300, 300, 0, 0, 120, 120, 120, 120, 120, 120, 180]

const processor = unified().use(retextEnglish)
const root = document.querySelector('#root')
let tree = render('The initial text.')
let dom = root.append(createElement(tree))

setTimeout(resize, 4)

function onchange(ev) {
    const next = render(ev.target.value)
    dom = patch(dom, diff(tree, next))
    tree = next
    setTimeout(resize, 4)
}

function render(text) {
    const node = parse(text)
    let key = 0

    return h('div', { className: 'editor' }, [
        h('div', { key: 'draw', className: 'draw' }, highlight(node)),
        h('textarea', {
            key: 'area',
            value: text,
            oninput: onchange
        })
    ])

    function parse(value) {
        return processor.runSync(processor.parse(value))
    }

    function highlight(node) {
        const results = []
        let index = -1

        while (++index < node.children.length) {
            results.push(...one(node.children[index]))
        }

        return results
    }

    function one(node) {
        const result = 'value' in node ? [node.value] : highlight(node)

        if (node.type === 'SentenceNode') {
            key++
            return [
                h(
                    'span',
                    { key: 's-' + key, style: { backgroundColor: color(count(node)) } },
                    result
                )
            ]
        }

        return result
    }

    function count(node) {
        let value = 0

        visit(node, 'WordNode', () => {
            value++
        })

        return value
    }

    function color(count) {
        const value = count < hues.length ? hues[count] : hues[hues.length - 1]
        return 'hsl(' + [value, '93%', '85%'].join(', ') + ')'
    }
}

function resize() {
    dom.lastChild.rows =
        Math.ceil(
            dom.firstChild.getBoundingClientRect().height /
            Number.parseInt(window.getComputedStyle(dom.firstChild).lineHeight, 10)
        ) + 1
}

```

### Further exercises

The above code has a few issues:

-    `onchange` is not [debounced](https://www.npmjs.com/package/debounce), which leads to performance issues
-    `input` events are not supported in some older browsers
-    The styles aren’t perfect
-    and probably some other things!

…maybe you could solve some? Other than those issues, it’s a pretty cool little demo.

If you haven’t already, check out the other articles in the [learn section](https://unifiedjs.com/learn/)!

### Debugging the Easy Way
This whole example is not yet working correctly for me. I've got console errs:

```
Uncaught TypeError: Cannot read properties of undefined (reading 'lastChild')
    at vn (build.js:9:7056)
120build.js:8 Uncaught TypeError: Cannot read properties of undefined (reading 'ownerDocument')
    at Object.io [as patch] (build.js:8:8344)
    at wt (build.js:8:8253)
    at HTMLTextAreaElement.Ho (build.js:9:6341)
```

Instead of trying to debug this, I'm just going to grab the project code now from GitHub: **[wooorm/write-music](https://github.com/wooorm/write-music)**. I've learned enough following along already, I don't need to waste time debugging my own code.

```bash
cd repos
git clone git@github.com:wooorm/write-music.git
cd write-music
npm i
npm test
```

That puts build results into `dest`, then you can just `code .` from dest and run the Live Server in VS Code.

## Lessons Learned

- [virtual-dom](https://www.npmjs.com/package/virtual-dom) is a interesting alternative to React that seems to be a very fast and efficient way to perform DOM manipulation. Is it any more or less efficient than React? I dunno, but it's an interesting alternative that I never heard of before this tutorial.
- [syntax-tree/unist-util-visit](https://github.com/syntax-tree/unist-util-visit) ( `import {visit} from 'unist-util-visit'`) allows you to create a visitor for visiting nodes in the abstract syntax tree.
- [retext](https://unifiedjs.com/explore/project/retextjs/retext/) plugin parses English natural language. [Parser](https://unifiedjs.com/explore/package/unified/#processorparser) for [unified](https://unifiedjs.com/explore/package/unified/). Parses English language prose to [nlcst](https://github.com/syntax-tree/nlcst) syntax trees.
- [debounce](https://www.npmjs.com/package/debounce) is useful for implementing behavior that should only happen after a repeated action has completed. Example:

```js
var debounce = require('debounce');
window.onresize = debounce(resize, 200);

function resize(e) {
  console.log('height', window.innerHeight);
  console.log('width', window.innerWidth);
}
```


